```python
# imports
import pytest  # used for our unit tests

# function to test
def factorial(x):
    if x == 1:
        return 1
    else:
        return (x * factorial(x-1))

# unit tests
# below, each test case is represented by a tuple passed to the @pytest.mark.parametrize decorator

# Test the function's behavior for a wide range of possible inputs
@pytest.mark.parametrize("test_input,expected", [(5, 120), (10, 3628800)])
def test_factorial_positive_integers(test_input, expected):
    assert factorial(test_input) == expected

# Test edge case - Small numbers
@pytest.mark.parametrize("test_input,expected", [(1, 1), (0, 1)])
def test_factorial_small_numbers(test_input, expected):
    assert factorial(test_input) == expected

# Test edge case - Large numbers
def test_factorial_large_numbers():
    assert isinstance(factorial(100), int)  # Just check if it returns an integer

# Test negative numbers
def test_factorial_negative_numbers():
    with pytest.raises(RecursionError):  # Expect a RecursionError for negative numbers
        factorial(-5)

# Test non-integer numbers
def test_factorial_non_integer_numbers():
    with pytest.raises(RecursionError):  # Expect a RecursionError for non-integer numbers
        factorial(4.5)

# Test non-numeric inputs
def test_factorial_non_numeric_inputs():
    with pytest.raises(TypeError):  # Expect a TypeError for non-numeric inputs
        factorial("five")
```
Please note that the original function does not handle negative numbers, non-integer numbers, and non-numeric inputs. It will raise a `RecursionError` for negative and non-integer numbers and a `TypeError` for non-numeric inputs. If you want the function to handle these cases differently, you would need to modify the function accordingly.